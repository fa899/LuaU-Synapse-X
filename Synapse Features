if _G.AlreadyExecuted == "yes" then return warn("Already executed the script!") else end -- Already executed check
oldloadstring = loadstring
_G.AlreadyExecuted = "yes"
--[[ Iris Instance Protect ]]--
local ProtectedInstances = {};
local Connections = getconnections or get_connections;
local HookFunction = HookFunction or hookfunction or hook_function or detour_function;
local GetNCMethod = getnamecallmethod or get_namecall_method;
local CheckCaller = checkcaller or check_caller;
local GetRawMT = get_raw_metatable or getrawmetatable or getraw_metatable;

assert(HookFunction  and GetNCMethod and CheckCaller and Connections, "Exploit is not supported");

local function HookMetaMethod(Object, MetaMethod, Function)
	return HookFunction(assert(GetRawMT(Object)[MetaMethod], "Invalid Method"), Function);
end 

local TblDataCache = {};
local FindDataCache = {};
local PropertyChangedData = {};
local InstanceConnections = {};
local NameCall, NewIndex;

local EventMethods = {
	"ChildAdded",
	"ChildRemoved",
	"DescendantRemoving",
	"DescendantAdded",
	"childAdded",
	"childRemoved",
	"descendantRemoving",
	"descendantAdded",
}
local TableInstanceMethods = {
	GetChildren = game.GetChildren,
	GetDescendants = game.GetDescendants,
	getChildren = game.getChildren,
	getDescendants = game.getDescendants,
	children = game.children,
}
local FindInstanceMethods = {
	FindFirstChild = game.FindFirstChild,
	FindFirstChildWhichIsA = game.FindFirstChildWhichIsA,
	FindFirstChildOfClass = game.FindFirstChildOfClass,
	findFirstChild = game.findFirstChild,
	findFirstChildWhichIsA = game.findFirstChildWhichIsA,
	findFirstChildOfClass = game.findFirstChildOfClass,
}
local NameCallMethods = {
	Remove = game.Remove;
	Destroy = game.Destroy;
	remove = game.remove;
	destroy = game.destroy;
}

for MethodName, MethodFunction in next, TableInstanceMethods do
	TblDataCache[MethodName] = HookFunction(MethodFunction, function(...)
		if not CheckCaller() then
			local ReturnedTable = TblDataCache[MethodName](...);

			if ReturnedTable then
				table.foreach(ReturnedTable, function(_, Inst)
					if table.find(ProtectedInstances, Inst) then
						table.remove(ReturnedTable, _);
					end
				end)

				return ReturnedTable;
			end
		end

		return TblDataCache[MethodName](...);
	end)
end

for MethodName, MethodFunction in next, FindInstanceMethods do
	FindDataCache[MethodName] = HookFunction(MethodFunction, function(...)
		if not CheckCaller() then
			local FindResult = FindDataCache[MethodName](...);

			if table.find(ProtectedInstances, FindResult) then
				FindResult = nil
			end
			for _, Object in next, ProtectedInstances do
				if Object == FindResult then
					FindResult = nil
				end
			end
		end
		return FindDataCache[MethodName](...);
	end)
end

local function GetParents(Object)
	local Parents = { Object.Parent };

	local CurrentParent = Object.Parent;

	while CurrentParent ~= game and CurrentParent ~= nil do
		CurrentParent = CurrentParent.Parent;
		table.insert(Parents, CurrentParent)
	end

	return Parents;
end

NameCall = HookMetaMethod(game, "__namecall", function(...)
	if not CheckCaller() then
		local ReturnedData = NameCall(...);
		local NCMethod = GetNCMethod();
		local self, Args = ...;

		if typeof(self) ~= "Instance" then return ReturnedData end
		if not ReturnedData then return nil; end;

		if TableInstanceMethods[NCMethod] then
			if typeof(ReturnedData) ~= "table" then return ReturnedData end;

			table.foreach(ReturnedData, function(_, Inst)
				if table.find(ProtectedInstances, Inst) then
					table.remove(ReturnedData, _);
				end
			end)

			return ReturnedData;
		end

		if FindInstanceMethods[NCMethod] then
			if typeof(ReturnedData) ~= "Instance" then return ReturnedData end;

			if table.find(ProtectedInstances, ReturnedData) then
				return nil;
			end
		end
	elseif CheckCaller() then
		local self, Args = ...;
		local Method = GetNCMethod();

		if NameCallMethods[Method] then
			if typeof(self) ~= "Instance" then return NewIndex(...) end

			if table.find(ProtectedInstances, self) and not PropertyChangedData[self] then
				local Parent = self.Parent;
				InstanceConnections[self] = {}

				if tostring(Parent) ~= "nil" then
					for _, ConnectionType in next, EventMethods do
						for _, Connection in next, Connections(Parent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
				end
				for _, Connection in next, Connections(game.ItemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, Connection in next, Connections(game.itemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, ParentObject in next, GetParents(self) do
					if tostring(ParentObject) ~= "nil" then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				PropertyChangedData[self] = true;
				self[Method](self);
				PropertyChangedData[self] = false;

				table.foreach(InstanceConnections[self], function(_,Connect) 
					Connect:Enable();
				end)
			end
		end
	end
	return NameCall(...);
end)
NewIndex = HookMetaMethod(game , "__newindex", function(...)
	if CheckCaller() then
		local self, Property, Value, UselessArgs = ...

		if typeof(self) ~= "Instance" then return NewIndex(...) end

		if table.find(ProtectedInstances, self) and not PropertyChangedData[self] then
			if rawequal(Property, "Parent") then
				local NewParent = Value;
				local OldParent = self.Parent;
				InstanceConnections[self] = {}

				for _, ConnectionType in next, EventMethods do
					if NewParent and NewParent.Parent ~= nil then
						for _, Connection in next, Connections(NewParent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
					if OldParent and OldParent ~= nil then
						for _, Connection in next, Connections(OldParent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
				end

				for _, ParentObject in next, GetParents(self) do
					if ParentObject and ParentObject.Parent ~= nil then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				for _, ParentObject in next, GetParents(NewParent) do
					if ParentObject and ParentObject.Parent ~= nil then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				for _, Connection in next, Connections(game.ItemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, Connection in next, Connections(game.itemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end

				PropertyChangedData[self] = true;
				self.Parent = NewParent;
				PropertyChangedData[self] = false;


				table.foreach(InstanceConnections[self], function(_,Connect) 
					Connect:Enable();
				end)

			end
		end
	end
	return NewIndex(...)
end)

local ProtectInstance = function(NewInstance)
	table.insert(ProtectedInstances, NewInstance)
end
local UnProtectInstance = function(NewInstance)
	table.remove(ProtectedInstances, table.find(ProtectedInstances, NewInstance));
end

local syn = {}
syn.protect_gui = ProtectInstance
syn.unprotect_gui = UnProtectInstance
syn.queue_on_teleport = queue_on_teleport or queueonteleport or qot or q_o_t
syn.is_beta = function() return true end
syn.request = request or fluxus and fluxus.request or http_request or http.request
syn.setthreadidentity = setidentity or set_identity or setthreadidentity or set_thread_identity

local hashes = {
	API = {},
	builtin = {
		["a"] = "gDsxyH",
		["b"] = "lGDpC",
		["c"] = "GmVlOdX",
		["d"] = "bbLxMkFms",
		["e"] = "SLgMvKdmC",
		["f"] = "DlMvKsUs",
		["g"] = "lMxIsAnV",
		["h"] = "PeVFmCXxx",
		["i"] = "LfMvKdcm",
		["j"] = "LvMxoIOf",
		["k"] = "LfMxLGiDmv",
		["l"] = "LvMxOIdMXX",
		["m"] = "DlCxOoppXe",
		["n"] = "FodSKkvlMX",
		["o"] = "OvkSlvMdikc==",
		["p"] = "ovMCkdSAOI",
		["q"] = "LvmAksxmvl",
		["r"] = "ldMvxNRmx",
		["t"] = "OckMSixmn",
		["v"] = "LXoKMdicmm",
		["s"] = "KvmXkmEgi",
		["x"] = "LvoASMvlkcx",
		["y"] = "OdgspjmBOD",
		["z"] = "kovfkMPdcxpo",
		[":"] = "CmkSAMNv",
		[";"] = "OvmSOimjv",
		["-"] = "LmvoSImvf",
		["+"] = "KOvkmASkvm",
		["_"] = "BkPSXOkv",
		["A"] = "gDsxyH",
		["B"] = "lGDpC",
		["C"] = "GmVlOdX",
		["D"] = "bbLxMkFms",
		["E"] = "SLgMvKdmC",
		["F"] = "DlMvKsUs",
		["G"] = "lMxIsAnV",
		["H"] = "PeVFmCXxx",
		["I"] = "LfMvKdcm",
		["J"] = "LvMxoIOf",
		["K"] = "LfMxLGiDmv",
		["L"] = "LvMxOIdMXX",
		["M"] = "DlCxOoppXe",
		["N"] = "FodSKkvlMX",
		["O"] = "OvkSlvMdikc==",
		["P"] = "ovMCkdSAOI",
		["Q"] = "LvmAksxmvl",
		["R"] = "ldMvxNRmx",
		["T"] = "OckMSixmn",
		["V"] = "LXoKMdicmm",
		["S"] = "KvmXkmEgi",
		["X"] = "LvoASMvlkcx",
		["Y"] = "OdgspjmBOD",
		["Z"] = "kovfkMPdcxpo",
		["w"] = "KVMklcsnbJD",
		["W"] = "KVMklcsnbJD",
		["/"] = 'OkcvkMDxlv',
		[ [[\]] ] = "PVmSkxKfm",
		["1"] = "obMDixmvSSS",
		["2"] = "XjnfJDncxlkm",
		["3"] = "ClxNJvkdn",
		["4"] = "glSDncmm",
		["5"] = "POpckxopMDvcxm",
		["6"] = "VMcxkAmvke",
		["7"] = "VOpsdmvjk",
		["8"] = "ODSjiov",
		["9"] = "dOSGnjjksvcx",
		["0"] = "9teuisodmg",
		["!"] = "dSObkcxok",
		[" "] = "oKGposdmvSLK",
		["u"] = "BoXMfdOSVM",
		["'"] = "BoXmcDjVn",
		['"'] = "SSBipksdmgosdB",
		["["] = "BOxSVpkm",
		["]"] = "VpBodXmjk",
		[","] = "BlkCKlmfdlk",
		["("] = "BVpoXpmvdsK",
		[")"] = "VKOiodsOVGjio",
		["\n"] = "BoDxSKvm",
		["."] = "VoXPoAsdfm",
		["="] = "VpSAXPokd",
		["?"] = "VlopDgmkl",
		["{"] = "COPvgksodp",
		["}"] = "Cogjdfsmok"
	},
	["reversed"] = {
		["Cogjdfsmok"] = "}",
		["COPvgksodp"] = "{",
		["VlopDgmkl"] = "?",
		["VpSAXPokd"] = "=",
		["VoXPoAsdfm"] = ".",
		["BoDxSKvm"] = "\n",
		["BlkCKlmfdlk"] = ",",
		["BOxSVpkm"] = "[",
		["VpBodXmjk"] = "]",
		["BoXmcDjVn"] = "'",
		["SSBipksdmgosdB"] = '"',
		["BoXMfdOSVM"] = "u",
		["oKGposdmvSLK"] = " ",
		["dSObkcxok"] = "!",
		["gDsxyH"] = "a",
		["lGDpC"] = "b",
		["GmVlOdX"] = "c",
		["bbLxMkFms"] = "d",
		["SLgMvKdmC"] = "e",
		["DlMvKsUs"] = "f",
		["lMxIsAnV"] = "g",
		["KVMklcsnbJD"] = "w",
		["PeVFmCXxx"] = "h",
		["LfMvKdcm"] = "i",
		["LvMxoIOf"] = "j",
		["LfMxLGiDmv"] = "k",
		["LvMxOIdMXX"] = "l",
		["DlCxOoppXe"] = "m",
		["FodSKkvlMX"] = "n",
		["OvkSlvMdikc=="] = "o",
		["ovMCkdSAOI"] = "p",
		["LvmAksxmvl"] = "q",
		["ldMvxNRmx"] = "r",
		["OckMSixmn"] = "t",
		["LXoKMdicmm"] = "v",
		["KvmXkmEgi"] = "s",
		["LvoASMvlkcx"] = "x",
		["OdgspjmBOD"] = "y",
		["kovfkMPdcxpo"] = "z",
		["CmkSAMNv"] = ":",
		["OvmSOimjv"] = ";",
		["LmvoSImvf"] = "-",
		["KOvkmASkvm"] = "+",
		["BkPSXOkv"] = "_",
		["/"] = 'OkcvkMDxlv',
		["PVmSkxKfm"] = [[\]],
		["obMDixmvSSS"] = "1",
		["XjnfJDncxlkm"] = "2",
		["ClxNJvkdn"] = "3",
		["glSDncmm"] = "4",
		["POpckxopMDvcxm"] = "5",
		["VMcxkAmvke"] = "6",
		["VOpsdmvjk"] = "7",
		["ODSjiov"] = "8",
		["dOSGnjjksvcx"] = "9",
		["9teuisodmg"] = "0",
		["BVpoXpmvdsK"] = "(",
		["VKOiodsOVGjio"] = ")"
	}
}

hashes.API.synapse_hash = function(msg: string)
	return ""..msg:gsub(".", function(_)
		return hashes.builtin[_] or "?"
	end)
end

hashes.API.synapse_decrypt = function(msg: string)
	local replace = function(a,b) msg = msg:gsub(a, b) end

	if msg:find("gDsxyH") then
		replace("gDsxyH","a")
	end
	if msg:find("lGDpC") then
		replace("lGDpC","b")
	end
	if msg:find("GmVlOdX") then
		replace("GmVlOdX","c")
	end
	if msg:find("dSObkcxok") then
		replace("dSObkcxok","!")
	end
	if msg:find("KVMklcsnbJD") then
		replace("KVMklcsnbJD","w")
	end
	if msg:find("bbLxMkFms") then
		replace("bbLxMkFms","d")
	end
	if msg:find("SLgMvKdmC") then
		replace("SLgMvKdmC","e")
	end
	if msg:find("DlMvKsUs") then
		replace("DlMvKsUs","f")
	end
	if msg:find("lMxIsAnV") then
		replace("lMxIsAnV","g")
	end
	if msg:find("PeVFmCXxx") then
		replace("PeVFmCXxx","h")
	end
	if msg:find("LfMvKdcm") then
		replace("LfMvKdcm","i")
	end
	if msg:find("LvMxoIOf") then
		replace("LvMxoIOf","j")
	end
	if msg:find("LfMxLGiDmv") then
		replace("LfMxLGiDmv","k")
	end
	if msg:find("LvMxOIdMXX") then
		replace("LvMxOIdMXX","l")
	end
	if msg:find("DlCxOoppXe") then
		replace("DlCxOoppXe","m")
	end
	if msg:find("FodSKkvlMX") then
		replace("FodSKkvlMX","n")
	end
	if msg:find("OvkSlvMdikc==") then
		replace("OvkSlvMdikc==","o")
	end
	if msg:find("ovMCkdSAOI") then
		replace("ovMCkdSAOI","p")
	end
	if msg:find("LvmAksxmvl") then
		replace("LvmAksxmvl","q")
	end
	if msg:find("ldMvxNRmx") then
		replace("ldMvxNRmx","r")
	end
	if msg:find("OckMSixmn") then
		replace("OckMSixmn","t")
	end
	if msg:find("LXoKMdicmm") then
		replace("LXoKMdicmm","v")
	end
	if msg:find("KvmXkmEgi") then
		replace("KvmXkmEgi","s")
	end
	if msg:find("LvoASMvlkcx") then
		replace("LvoASMvlkcx","x")
	end
	if msg:find("OdgspjmBOD") then
		replace("OdgspjmBOD","y")
	end
	if msg:find("kovfkMPdcxpo") then
		replace("kovfkMPdcxpo","z")
	end
	if msg:find("kovfkMPdcxpo") then
		replace("kovfkMPdcxpo","z")
	end
	if msg:find("oKGposdmvSLK") then
		replace("oKGposdmvSLK"," ")
	end
	if msg:find("BoXMfdOSVM") then
		replace("BoXMfdOSVM","u")
	end
	if msg:find("SSBipksdmgosdB") then
		replace("SSBipksdmgosdB",'"')
	end
	if msg:find("BoXmcDjVn") then
		replace("BoXmcDjVn","'")
	end
	if msg:find("BOxSVpkm") then
		replace("BOxSVpkm","[")
	end
	if msg:find("VpBodXmjk") then
		replace("VpBodXmjk","]")
	end
	if msg:find("BlkCKlmfdlk") then
		replace("BlkCKlmfdlk",",")
	end
	if msg:find("BVpoXpmvdsK") then
		replace("BVpoXpmvdsK","(")
	end
	if msg:find("VKOiodsOVGjio") then
		replace("VKOiodsOVGjio",")")
	end
	if msg:find("BoDxSKvm") then
		replace("BoDxSKvm","\n")
	end
	if msg:find("VoXPoAsdfm") then
		replace("VoXPoAsdfm",".")
	end
	if msg:find("VpSAXPokd") then
		replace("VpSAXPokd","=")
	end
	if msg:find("VlopDgmkl") then
		replace("VlopDgmkl","?")
	end
	if msg:find("COPvgksodp") then
		replace("COPvgksodp","{")
	end
	if msg:find("Cogjdfsmok") then
		replace("Cogjdfsmok","}")
	end

	return msg
end

syn.sha_encrypt = hashes.API.synapse_hash
syn.sha_decrypt = hashes.API.synapse_decrypt

syn.create_secure_function = function(sha_code)
	return function() 
		pcall(function() loadstring("pcall(function()\n"..syn.sha_decrypt(sha_code).."\nend)")() end)
	end
end

syn.run_secure_function = function(func_or_sha)
	if type(func_or_sha) == "string" then
		return syn.create_secure_function(syn.sha_decrypt(func_or_sha))()
	elseif type(func_or_sha) == "function" then
		return (function() return pcall(func_or_sha) end)()
	end
end

syn.create_instance = function(inst, protectinstance, parentobject, instancesettings)
	local instance = Instance.new(inst)
	if protectinstance ~= nil and type(protectinstance) == "boolean" and protectinstance == true then
		syn.protect_gui(instance)
	end
	instance.Parent = parentobject
	for i, v in pairs(instancesettings) do
		instance[i] = v
	end
	return instance
end
syn.hook_namecall = function(func)
	local metatable = GetRawMT(game)
	if setreadonly then setreadonly(metatable, false) elseif make_writeable then make_writeable(metatable, false) elseif makewriteable then makewriteable(metatable, false) end
	metatable.__namecall = newcclosure(func)
	if setreadonly then setreadonly(metatable, true) elseif make_writeable then make_writeable(metatable, true) elseif makewriteable then makewriteable(metatable, true) end
end
syn.hook_index = function(func)
	local metatable = GetRawMT(game)
	if setreadonly then setreadonly(metatable, false) elseif make_writeable then make_writeable(metatable, false) elseif makewriteable then makewriteable(metatable, false) end
	metatable.__newindex = newcclosure(func)
	if setreadonly then setreadonly(metatable, true) elseif make_writeable then make_writeable(metatable, true) elseif makewriteable then makewriteable(metatable, true) end
end
local olddecompile = decompile or de_compile
local newdecompile = function(script)
	assert(script.ClassName, "#1 argument is not an instance!")
	if script:IsA("LocalScript") or script:IsA("ModuleScript") then
	else
		error("Failed to decompile, must be an LocalScript or ModuleScript, got "..script.ClassName == "Script" and "ServerScript" or script.ClassName..".")
	end
	local decompiled_src = olddecompile(script)
	decompiled_src = "-- Decompiled with the Synapse X Luau decompiler.\n"..decompiled_src
	if decompiled_src:find("local v") then
		decompiled_src = string.gsub(decompiled_src, "local v", "local I_SYN_")
	end
	if decompiled_src:find("= v") then
		decompiled_src = string.gsub(decompiled_src, "= v", "= I_SYN_")
	end
	if decompiled_src:find("= (v") then
		decompiled_src = string.gsub(decompiled_src, "= (v", "= (I_SYN_")
	end
	if decompiled_src:find(", v") then
		decompiled_src = string.gsub(decompiled_src, ", v", ", I_SYN_")
	end
	if decompiled_src:find("{v") then
		decompiled_src = string.gsub(decompiled_src, "{v", "{I_SYN_")
	end
	if decompiled_src:find("v = ") then
		decompiled_src = string.gsub(decompiled_src, "v = ", "I_SYN_ = ")
	end
	if decompiled_src:find("and v") then
		decompiled_src = string.gsub(decompiled_src, "and v", "and I_SYN_")
	end
	if decompiled_src:find("if v") then
		decompiled_src = string.gsub(decompiled_src, "if v", "if I_SYN_")
	end
	if decompiled_src:find("if not v") then
		decompiled_src = string.gsub(decompiled_src, "if not v", "if not I_SYN_")
	end
	if decompiled_src:find("return v") then
		decompiled_src = string.gsub(decompiled_src, "return v", "return I_SYN_")
	end
	if decompiled_src:find("#v") then
		decompiled_src = string.gsub(decompiled_src, "#v", "#I_SYN_")
	end
	for i = 1, 760 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i), "I_SYN_"..i)
	end
	for i = 1, 760 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), "I_SYN_"..i..".")
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i), tostring("I_SYN_"..i))
		if not decompiled_src:find("I_SYN_"..tostring(i)) then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i), tostring("I_SYN_"..i))
		else
			break
		end
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), tostring("I_SYN_"..i.."."))
		if not decompiled_src:find("I_SYN_"..tostring(i)..".") then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), tostring("I_SYN_"..i.."."))
		else
			break
		end
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.." ="), tostring("I_SYN_"..i.." ="))
		if not decompiled_src:find("I_SYN_"..tostring(i).." =") then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i.." ="), tostring("I_SYN_"..i.." ="))
		else
			break
		end
	end
	return decompiled_src
end
syn.better_decompile = function(script)
	return newdecompile(script)
end
syn.decompile = function(script)
	return newdecompile(script)
end
getgenv().syn = syn
