if _G.AlreadyExecuted == "yes" then
return warn("Already executed the script!")
else
-- lol
end
_G.AlreadyExecuted = "yes"
--[[ Iris Instance Protect ]]--
local ProtectedInstances = {};
local Connections = getconnections or get_connections;
local HookFunction = HookFunction or hookfunction or hook_function or detour_function;
local GetNCMethod = getnamecallmethod or get_namecall_method;
local CheckCaller = checkcaller or check_caller;
local GetRawMT = get_raw_metatable or getrawmetatable or getraw_metatable;

assert(HookFunction  and GetNCMethod and CheckCaller and Connections, "Exploit is not supported");

local function HookMetaMethod(Object, MetaMethod, Function)
	return HookFunction(assert(GetRawMT(Object)[MetaMethod], "Invalid Method"), Function);
end 

local TblDataCache = {};
local FindDataCache = {};
local PropertyChangedData = {};
local InstanceConnections = {};
local NameCall, NewIndex;

local EventMethods = {
	"ChildAdded",
	"ChildRemoved",
	"DescendantRemoving",
	"DescendantAdded",
	"childAdded",
	"childRemoved",
	"descendantRemoving",
	"descendantAdded",
}
local TableInstanceMethods = {
	GetChildren = game.GetChildren,
	GetDescendants = game.GetDescendants,
	getChildren = game.getChildren,
	getDescendants = game.getDescendants,
	children = game.children,
}
local FindInstanceMethods = {
	FindFirstChild = game.FindFirstChild,
	FindFirstChildWhichIsA = game.FindFirstChildWhichIsA,
	FindFirstChildOfClass = game.FindFirstChildOfClass,
	findFirstChild = game.findFirstChild,
	findFirstChildWhichIsA = game.findFirstChildWhichIsA,
	findFirstChildOfClass = game.findFirstChildOfClass,
}
local NameCallMethods = {
	Remove = game.Remove;
	Destroy = game.Destroy;
	remove = game.remove;
	destroy = game.destroy;
}

for MethodName, MethodFunction in next, TableInstanceMethods do
	TblDataCache[MethodName] = HookFunction(MethodFunction, function(...)
		if not CheckCaller() then
			local ReturnedTable = TblDataCache[MethodName](...);

			if ReturnedTable then
				table.foreach(ReturnedTable, function(_, Inst)
					if table.find(ProtectedInstances, Inst) then
						table.remove(ReturnedTable, _);
					end
				end)

				return ReturnedTable;
			end
		end

		return TblDataCache[MethodName](...);
	end)
end

for MethodName, MethodFunction in next, FindInstanceMethods do
	FindDataCache[MethodName] = HookFunction(MethodFunction, function(...)
		if not CheckCaller() then
			local FindResult = FindDataCache[MethodName](...);

			if table.find(ProtectedInstances, FindResult) then
				FindResult = nil
			end
			for _, Object in next, ProtectedInstances do
				if Object == FindResult then
					FindResult = nil
				end
			end
		end
		return FindDataCache[MethodName](...);
	end)
end

local function GetParents(Object)
	local Parents = { Object.Parent };

	local CurrentParent = Object.Parent;

	while CurrentParent ~= game and CurrentParent ~= nil do
		CurrentParent = CurrentParent.Parent;
		table.insert(Parents, CurrentParent)
	end

	return Parents;
end

NameCall = HookMetaMethod(game, "__namecall", function(...)
	if not CheckCaller() then
		local ReturnedData = NameCall(...);
		local NCMethod = GetNCMethod();
		local self, Args = ...;

		if typeof(self) ~= "Instance" then return ReturnedData end
		if not ReturnedData then return nil; end;

		if TableInstanceMethods[NCMethod] then
			if typeof(ReturnedData) ~= "table" then return ReturnedData end;

			table.foreach(ReturnedData, function(_, Inst)
				if table.find(ProtectedInstances, Inst) then
					table.remove(ReturnedData, _);
				end
			end)

			return ReturnedData;
		end

		if FindInstanceMethods[NCMethod] then
			if typeof(ReturnedData) ~= "Instance" then return ReturnedData end;

			if table.find(ProtectedInstances, ReturnedData) then
				return nil;
			end
		end
	elseif CheckCaller() then
		local self, Args = ...;
		local Method = GetNCMethod();

		if NameCallMethods[Method] then
			if typeof(self) ~= "Instance" then return NewIndex(...) end

			if table.find(ProtectedInstances, self) and not PropertyChangedData[self] then
				local Parent = self.Parent;
				InstanceConnections[self] = {}

				if tostring(Parent) ~= "nil" then
					for _, ConnectionType in next, EventMethods do
						for _, Connection in next, Connections(Parent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
				end
				for _, Connection in next, Connections(game.ItemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, Connection in next, Connections(game.itemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, ParentObject in next, GetParents(self) do
					if tostring(ParentObject) ~= "nil" then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				PropertyChangedData[self] = true;
				self[Method](self);
				PropertyChangedData[self] = false;

				table.foreach(InstanceConnections[self], function(_,Connect) 
					Connect:Enable();
				end)
			end
		end
	end
	return NameCall(...);
end)
NewIndex = HookMetaMethod(game , "__newindex", function(...)
	if CheckCaller() then
		local self, Property, Value, UselessArgs = ...

		if typeof(self) ~= "Instance" then return NewIndex(...) end

		if table.find(ProtectedInstances, self) and not PropertyChangedData[self] then
			if rawequal(Property, "Parent") then
				local NewParent = Value;
				local OldParent = self.Parent;
				InstanceConnections[self] = {}

				for _, ConnectionType in next, EventMethods do
					if NewParent and NewParent.Parent ~= nil then
						for _, Connection in next, Connections(NewParent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
					if OldParent and OldParent ~= nil then
						for _, Connection in next, Connections(OldParent[ConnectionType]) do
							table.insert(InstanceConnections[self], Connection);
							Connection:Disable();
						end
					end
				end

				for _, ParentObject in next, GetParents(self) do
					if ParentObject and ParentObject.Parent ~= nil then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				for _, ParentObject in next, GetParents(NewParent) do
					if ParentObject and ParentObject.Parent ~= nil then
						for _, ConnectionType in next, EventMethods do
							for _, Connection in next, Connections(ParentObject[ConnectionType]) do
								table.insert(InstanceConnections[self], Connection);
								Connection:Disable();
							end
						end
					end
				end

				for _, Connection in next, Connections(game.ItemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end
				for _, Connection in next, Connections(game.itemChanged) do
					table.insert(InstanceConnections[self], Connection);
					Connection:Disable();
				end

				PropertyChangedData[self] = true;
				self.Parent = NewParent;
				PropertyChangedData[self] = false;


				table.foreach(InstanceConnections[self], function(_,Connect) 
					Connect:Enable();
				end)

			end
		end
	end
	return NewIndex(...)
end)

local ProtectInstance = function(NewInstance)
	table.insert(ProtectedInstances, NewInstance)
end
local UnProtectInstance = function(NewInstance)
	table.remove(ProtectedInstances, table.find(ProtectedInstances, NewInstance));
end

local syn = {}
syn.protect_gui = ProtectInstance
syn.unprotect_gui = UnProtectInstance
syn.is_protected = function(inst)
	if table.find(ProtectedInstances, inst) then
		return true
	elseif not table.find(ProtectedInstances, inst) then
		return false
	end
end
syn.queue_on_teleport = queue_on_teleport or queueonteleport or qot or q_o_t
syn.is_beta = function() return true end
syn.request = request or fluxus and fluxus.request or http_request or http.request
syn.setthreadidentity = setidentity or set_identity
syn.create_secure_function = function(func)
	pcall(func)
end
syn.create_instance = function(inst, protectinstance, parentobject, instancesettings)
	local instance = Instance.new(inst)
	if protectinstance ~= nil and type(protectinstance) == "boolean" and protectinstance == true then
		syn.protect_gui(instance)
	end
	instance.Parent = parentobject
	for i, v in pairs(instancesettings) do
		instance[i] = v
	end
	return instance
end
syn.hook_namecall = function(func)
	local metatable = GetRawMT(game)
	if setreadonly then setreadonly(metatable, false) elseif make_writeable then make_writeable(metatable, false) elseif makewriteable then makewriteable(metatable, false) end
	metatable.__namecall = newcclosure(func)
	if setreadonly then setreadonly(metatable, true) elseif make_writeable then make_writeable(metatable, true) elseif makewriteable then makewriteable(metatable, true) end
end
syn.hook_index = function(func)
	local metatable = GetRawMT(game)
	if setreadonly then setreadonly(metatable, false) elseif make_writeable then make_writeable(metatable, false) elseif makewriteable then makewriteable(metatable, false) end
	metatable.__namecall = newcclosure(func)
	if setreadonly then setreadonly(metatable, true) elseif make_writeable then make_writeable(metatable, true) elseif makewriteable then makewriteable(metatable, true) end
end
local olddecompile = decompile or de_compile
local newdecompile = function(script)
	assert(script.ClassName, "#1 argument is not an instance!")
	if script:IsA("LocalScript") or script:IsA("ModuleScript") then
	else
		error("Failed to decompile, must be an LocalScript or ModuleScript, got "..script.ClassName == "Script" and "ServerScript" or script.ClassName..".")
	end
	local decompiled_src = olddecompile(script)
	decompiled_src = "-- Decompiled using Synapse X LuaU Decompiler.\n"..decompiled_src
	decompiled_src = string.gsub(decompiled_src, "local v", "local I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "= v", "= I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "= (v", "= (I_SYN_")
	decompiled_src = string.gsub(decompiled_src, ", v", ", I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "{v", "{I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "v = ", "I_SYN_ = ")
	decompiled_src = string.gsub(decompiled_src, "and v", "and I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "if v", "if I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "if not v", "if not I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "return v", "return I_SYN_")
	decompiled_src = string.gsub(decompiled_src, "#v", "#I_SYN_")
	for i = 1, 760 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i), "I_SYN_"..i)
	end
	for i = 1, 760 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), "I_SYN_"..i..".")
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i), tostring("I_SYN_"..i))
		if not decompiled_src:find("I_SYN_"..tostring(i)) then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i), tostring("I_SYN_"..i))
		else
			break
		end
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), tostring("I_SYN_"..i.."."))
		if not decompiled_src:find("I_SYN_"..tostring(i)..".") then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i.."."), tostring("I_SYN_"..i.."."))
		else
			break
		end
	end
	for i = 1, #decompiled_src + 1 do
		decompiled_src = string.gsub(decompiled_src, tostring("v"..i.." ="), tostring("I_SYN_"..i.." ="))
		if not decompiled_src:find("I_SYN_"..tostring(i).." =") then
			decompiled_src = string.gsub(decompiled_src, tostring("v"..i.." ="), tostring("I_SYN_"..i.." ="))
		else
			break
		end
	end
	return decompiled_src
end
syn.better_decompile = function(script)
	return newdecompile(script)
end
syn.decompile = function(script)
	return newdecompile(script)
end

(function()
local folders = {
	["1"] = syn.create_instance("Configuration", true, game.CoreGui, {}),
	["2"] = syn.create_instance("Folder", true, game.CoreGui, {}),
	["3"] = syn.create_instance("Model", true, game.CoreGui, {}),
}

for i, v in pairs(folders) do
folders[tostring(i)].ChildAdded:Connect(function(i)
syn.protect_gui(i)
end)
folders[tostring(i)].ChildRemoving:Connect(function(i)
syn.protect_gui(i)
end)
end

getgenv().gethui = function()
return folders[tostring(math.random(1,3))]
end
end)();
function findNearestSeat()
	local seat: Seat = nil; do
		repeat 
			local counter = 0
			for i, v in pairs(workspace:GetDescendants()) do
				if v:IsA("Seat") then
					seat = v
				elseif v:IsA("VehicleSeat") then
					seat = v
				end
				game:GetService("RunService").Heartbeat:wait()
			end

			counter += 1
			wait()
			if counter >= 3 then
				warn("findNearestSeat failed, reason: failed to find a seat.")
				break
			end
		until seat ~= nil
		return seat
	end
end

function safe_teleport(args, mode)
	if type(args.TargetPosition) ~= "vector" then
		warn("Failed to run safe_teleport, As TargetPosition expected Vector3, got "..typeof(args.TargetPosition)..".")
		return false
	end	
	local tweenspeed = args.TweenSpeed
	local targetpos = args.TargetPosition
	local m = mode
	local vec3_, cf = Vector3.new(targetpos), CFrame.new(targetpos)
	if tweenspeed then
		if type(tweenspeed) ~= "number" then
			warn("Failed to run safe_teleport, As TweenSpeed expected number, got "..type(tweenspeed)..".")
			return false
		end
	end

	local c = game.Players.LocalPlayer.Character
	local p = c.PrimaryPart
	local h = c:FindFirstChildWhichIsA("Humanoid")
	local is_alive = false

	if not p then
		warn("Failed to run safe_teleport, because player's character does not have an primary part, or is reanimated without an primary part.")
		return false
	end

	if h and h.Health >= 0 then
		is_alive = true
	end

	if is_alive ~= true then
		warn("Failed to run safe_teleport, because player's character is not alive.")
		return false
	end

	if mode == "tween" then
		return game:GetService("TweenService"):Create(p, TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = cf}):Play()
	elseif mode == "platformtween" then
		for i = 1, 10 do
			local vec3 = Instance.new("Vector3Value")
			local pf = Instance.new("Part", workspace)
			local tween = game:GetService("TweenService"):Create(vec3, TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {Value = cf.Position})
			pf.Anchored = true
			pf.CanCollide = true
			pf.Transparency = 0.5

			vec3.Value = p.Position

			vec3.Changed:Connect(function(v)
				p.Velocity = Vector3.new(0, 0, 0) --[[AntiTeleport Flag Bypass]]
				p.CFrame = CFrame.new(vec3.Value)
				pf.CFrame = p.CFrame + p.CFrame.UpVector * -3.5
			end)

			tween.Completed:Connect(function()
				pf:Destroy()
				vec3:Destroy()
				tween = nil
			end)

			tween:Play()
			wait()
		end
	elseif mode == "chair" then
		local seat = findNearestSeat()
		if seat then
			local oldcf = seat.CFrame
			wait(.1)
			seat.CFrame = p.CFrame
			seat:Sit(h)
			seat.CFrame = cf
			wait(.5)
			h.Sit = false
			wait()
			seat.CFrame = oldcf
			h.Sit = false
		elseif not seat then
			error("Failed to find a seat for safe_teleport. (The map may not have a seat)")
			return false
		end
	elseif mode == "hoodmodded" then
		game:GetService("TweenService"):Create(p, TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = cf}):Play()
	elseif mode == "rocket" then
		local rocketspeed = 0.2
		local first, second, third = game:GetService("TweenService"):Create(p, TweenInfo.new(rocketspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = p.CFrame + p.CFrame.UpVector * 5}), game:GetService("TweenService"):Create(p, TweenInfo.new(tweenspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = cf}), game:GetService("TweenService"):Create(p, TweenInfo.new(rocketspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = p.CFrame + p.CFrame.UpVector * -2})
		first.Completed:Connect(function()
			second:Play()
		end)
		second.Completed:Connect(function()
			--[[
				--[??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????
				??????????????????????????????????????????]--
			--]]
		end)
		third.Completed:Connect(function()
			first, second, third = nil, nil, nil
		end)
		first:Play()
	elseif mode == "antilagback" then
		local conn = game:GetService("RunService").Stepped:Connect(function()
			for i, v in pairs(c:GetChildren()) do
				if v.ClassName:lower():find("part") and not v.ClassName:lower():find("icle") then
					v.CanCollide = false
				end
			end
		end)
		repeat
			local num = 51011
			local bodypos = Instance.new("BodyPosition")
			local velo = Instance.new("BodyVelocity")
			velo.Parent = p
			velo.Velocity = Vector3.new(0, 0, 0)
			velo.P = num
			bodypos.Parent = p
			bodypos.Position = targetpos
			bodypos.MaxForce = Vector3.new(num, num, num)
			bodypos.P = num
			wait(3)
			bodypos:Destroy()
			velo:Destroy()
		until (p.Position - targetpos).Magnitude <= 20
		conn:Disconnect()
		conn = nil
	end

	return true
end

syn.secure_teleport = safe_teleport
getgenv().syn = syn
getgenv().decompile = newdecompile
